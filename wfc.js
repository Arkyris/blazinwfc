import Tile from './tile.js';
import Cell from './cell.js';

/**
 * @description: The wave function collapse algorithm for procedurally generating 2D maps
 * @param {Object} definition - The definition of algorithm options and tiles 
 * @property {Object} saveIntervalPercentage - The percentage of cells that need to be collapsed before the map is saved defined in the options (0.025 = 2.5%)
 * @property {Object} tiles - The tiles used in the algorithm
 * @property {Object} grid - A 2D array of cells
 * @property {Object} finalMap - The final map generated by the algorithm (2D array of tile indexes)
 * @property {Object} priorityQueue - The priority queue used by the algorithm (2D array of cell coordinates)
 * @property {Object} previousStates - The previous state of the algorithm (Used for rollback)
 * @property {Object} collapsedCells - The number of cells that have been collapsed
 * @property {Object} totalCells - The total number of cells in the map
 * @property {Object} saveInterval - The percentage of cells that need to be collapsed before the map is saved used by the algorithm
 * @property {Object} saveNext - A boolean that determines if the the state should be saved on the next iteration
 * @property {Object} nextSave - The number of cells that need to be collapsed before the map is saved
 * @property {Object} changedCells - The cells that have been changed since the last save (Used for rollback)
 * @property {Object} width - The width of the map
 * @property {Object} priorityQueueWidth - The width of the priority queue (Set to the max number of options a tile has in one direction)
 */
export default function WFC(definition) {
    const saveIntervalPercentage = definition.options.saveInterval || 0.02;
    let tiles = [];
    let grid;
    let finalMap;
    let priorityQueue;
    let previousStates;
    let collapsedCells;
    let totalCells;
    let saveInterval;
    let saveNext;
    let nextSave;
    let changedCells;
    let width;

    // Fill the tiles array with the tiles from the definition
    for (let i = 0; i < definition.tiles.length; i++) {
        tiles.push(createTile(definition.tiles[i].edges, i, definition.tiles[i].type, definition.tiles[i].exceptions, definition.tiles[i].weight));
    }
    // Analyze the tiles edges to get the possible options for each tile
    for (let i = 0; i < tiles.length; i++) {
        tiles[i].analyze(tiles);
    }

    const priorityQueueWidth = setPQWidth();

    /**
     * @description: Collapse a new grid using the WFC algorithm and return the final map
     * @param {Number} width - The width of the map
     * @returns {Number[][]} this.finalMap
     */
    function collapse(newWidth) {
        resetState(newWidth);
        // The coordinates of the next cell to collapse
        let coords;
        // The current cell
        let cell;
        while (collapsedCells < totalCells) {
            if (collapsedCells === 0) {
                cell = getRandomCell();
                cell.options = Array(tiles.length).fill().map((_, i) => i);
                collapseCell(cell);
                changedCells.push({ x: cell.x, y: cell.y });
                finalMap[cell.x][cell.y] = cell.index;
                updateNeighbors(cell);
            } else {
                coords = getNextCell();
                cell = grid[coords.x][coords.y];
                if (cell.options > 1) {
                    updateSelf(cell);
                }
                if (cell.options.length === 0) {
                    rollback();
                    continue;
                }
                if (collapsedCells >= nextSave) {
                    nextSave += saveInterval;
                    saveNext = true;
                }
                if (saveNext === true && cell.options.length > 2 && previousStates.priorityQueue[0].length === 0 && previousStates.priorityQueue[1].length === 0) {
                    previousStates.collapsedCells = collapsedCells;
                    previousStates.priorityQueue = JSON.parse(JSON.stringify(priorityQueue));
                    for (let i = 0; i < changedCells.length; i++) {
                        previousStates.grid[changedCells[i].x][changedCells[i].y] = JSON.parse(JSON.stringify(grid[changedCells[i].x][changedCells[i].y]));
                    }
                    changedCells = [];
                    saveNext = false;
                }
                cell.inQueue = false;
                collapseCell(cell);
                changedCells.push({ x: cell.x, y: cell.y });
                finalMap[cell.x][cell.y] = cell.index;
                if (updateNeighbors(cell)) {
                    rollback();
                    continue;
                }
            }
            collapsedCells++;
        }
        return finalMap;
    }

    /**
     * @description: Rollback the algorithm to the saved state
     */
    function rollback() {
        for (let i = 0; i < changedCells.length; i++) {
            grid[changedCells[i].x][changedCells[i].y] = JSON.parse(JSON.stringify(previousStates.grid[changedCells[i].x][changedCells[i].y]));
        }
        collapsedCells = previousStates.collapsedCells;
        priorityQueue = JSON.parse(JSON.stringify(previousStates.priorityQueue));
        changedCells = [];
    }

    /**
     * @description: Collapse a cell down to a single option
     * @param {Object} cell - The cell to collapse
     */
    function collapseCell(cell) {
        if (!cell.collapsed) {
            cell.collapsed = true;
            const optionWeights = cell.options.map(option => tiles[option].weight);
            cell.index = weightedRandom(cell.options, optionWeights);
            cell.options = [cell.index];
        }
    }

    /**
     * @description: Create a new tile object from the given parameters
     * @param {String[]} edges - The tiles sockets
     * @param {Number} index - The index of the tile
     * @param {String} type - The type of the tile (Used for neighbor exceptions)
     * @param {String[]} exceptions - The tiles that cannot be neighbors
     * @param {Number} weight - The weight of the tile (The probability of the tile being selected)
     * @returns {Object} new Tile
     */
    function createTile(edges, index, type, exceptions = {}, weight = 10) {
        return new Tile(edges, index, type, exceptions, weight);
    }

    /**
     * @description: Get the valid options for a cell by comparing the cells options to the options of the tiles in the given direction
     * @param {Number[]} arr - The array of the cells current options 
     * @param {Number[]} valid - The array of valid options for the cell gotten from the tiles direction
     */
    function checkValid(arr, valid) {
        for (let i = arr.length - 1; i >= 0; i--) {
            let element = arr[i];
            if (!valid.includes(element)) {
                arr.splice(i, 1);
            }
        }
    }

    /**
     * @description: Get a random cell from the grid
     * @returns {Object} - The random cell
     */
    function getRandomCell() {
        let x = Math.floor(Math.random() * width);
        let y = Math.floor(Math.random() * width);
        return grid[x][y];
    }

    /**
     * @description: Get a random next cells coordinates from the priority queue and remove it from the queue
     * @returns {Object} - The next cells coordinates
     */
    function getNextCell() {
        for (let i = 0; i < priorityQueue.length; i++) {
            if (priorityQueue[i].length > 0) {
                let randomIndex = Math.floor(Math.random() * priorityQueue[i].length);
                return priorityQueue[i].splice(randomIndex, 1)[0];
            }
        }
    }

    /**
     * @description: Get a random index from the options using the weights
     * @param {Number[]} options - The options of the cell
     * @param {Number[]} weights - The weights of the options
     * @returns {Number} - The random index
     */
    function weightedRandom(options, weights) {
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        const randomWeight = Math.random() * totalWeight;
        let weightSum = 0;
        for (let i = 0; i < options.length; i++) {
            weightSum += weights[i];
            if (randomWeight <= weightSum) {
                return options[i];
            }
        }
        return options[options.length - 1];
    }

    /**
     * @description: Update the neighbors of the cell and push them to the priority queue
     * @param {Object} cell - The cell to update the neighbors of
     * @returns true if the algorithm needs to rollback because a neighbor has no options
     */
    function updateNeighbors(cell) {
        const directions = {
            0: 'up',
            1: 'right',
            2: 'down',
            3: 'left'
        };
        let neighbors = getNeighbors(cell);
        for (let i = 0; i < neighbors.length; i++) {
            if (!neighbors[i].collapsed) {
                if (neighbors[i].inQueue) {
                    priorityQueue[neighbors[i].options.length - 1] = priorityQueue[neighbors[i].options.length - 1].filter(cell => cell.x !== neighbors[i].x || cell.y !== neighbors[i].y);
                }
                if (!neighbors[i].options) {
                    neighbors[i].options = JSON.parse(JSON.stringify(tiles[cell.index][directions[i]]));
                }
                updateSelf(neighbors[i]);
                changedCells.push({ x: neighbors[i].x, y: neighbors[i].y });
                if (neighbors[i].options.length === 0) {
                    return true;
                }
                priorityQueue[neighbors[i].options.length - 1].push({ x: neighbors[i].x, y: neighbors[i].y });
                neighbors[i].inQueue = true;
            }
        }
    }

    /**
     * @description: Update the cell based on its neighbors options
     * @param {Object} Cell - The cell to update
     */
    function updateSelf(cell) {
        const directions = {
            0: 'down',
            1: 'left',
            2: 'up',
            3: 'right'
        };
        let neighbors = getNeighbors(cell);
        for (let j = 0; j < neighbors.length; j++) {
            let validOptions = [];
            if (neighbors[j].options) {
                for (let option of neighbors[j].options) {
                    let valid = tiles[option][directions[j]];
                    validOptions = validOptions.concat(valid);
                }
                checkValid(cell.options, validOptions);
            }
        }
    }

    /**
     * @description: Get the neighbors of the cell in the order up, right, down, left wrapping around the grid
     * @param {Object} Cell - The cell to get the neighbors of 
     * @returns {Object[]} - The neighbors of the cell
     */
    function getNeighbors(cell) {
        let neighbors = [];
        if (cell.x - 1 >= 0) {
            neighbors.push(grid[cell.x - 1][cell.y]);
        } else {
            neighbors.push(grid[width - 1][cell.y]);
        }
        if (cell.y + 1 < width) {
            neighbors.push(grid[cell.x][cell.y + 1]);
        } else {
            neighbors.push(grid[cell.x][0]);
        }
        if (cell.x + 1 < width) {
            neighbors.push(grid[cell.x + 1][cell.y]);
        } else {
            neighbors.push(grid[0][cell.y]);
        }
        if (cell.y - 1 >= 0) {
            neighbors.push(grid[cell.x][cell.y - 1]);
        } else {
            neighbors.push(grid[cell.x][width - 1]);
        }
        return neighbors;
    }

    /**
     * @description: Set all the variables to their initial values
     * @param {Number} newWidth - The width of the grid 
     */
    function resetState(newWidth) {
        grid = Array.from(Array(newWidth), (_, x) => Array.from(Array(newWidth), (_, y) => new Cell(x, y)));
        finalMap = Array.from(Array(newWidth), () => new Array(newWidth).fill(null));
        priorityQueue = Array.from(Array(priorityQueueWidth), () => []);
        collapsedCells = 0;
        saveNext = false;
        nextSave = 0;
        changedCells = [];
        width = newWidth;
        totalCells = newWidth * newWidth;
        saveInterval = Math.floor(totalCells * saveIntervalPercentage);
        previousStates = { grid: JSON.parse(JSON.stringify(grid)), collapsedCells: collapsedCells, priorityQueue: JSON.parse(JSON.stringify(priorityQueue)) };
    }

    /**
     * @description: A function to test the performance of the algorithm
     * @param {Number} newWidth - The width of the grid
     * @param {Number} iterations - The number of iterations to test (Start with 1 to get a baseline time then increase to get a more average time)
     */
    function test(newWidth, iterations) {
        let totalTime = 0;
        for (let i = 0; i < iterations; i++) {
            let start = Date.now();
            collapse(newWidth);
            let end = Date.now();
            totalTime += (end - start);
        }
        console.log((totalTime / iterations) / 1000);
    }

    /**
     * @description: Set the width of the priority queue
     * @returns {Number} - The max number of options of all tiles in one direction
     */
    function setPQWidth() {
        // for each tile check all directions and get the max number of options
        // a directions map
        let directions = {
            0: 'up',
            1: 'right',
            2: 'down',
            3: 'left'
        };

        let max = 0;
        for (let i = 0; i < tiles.length; i++) {
            for (let j = 0; j < 4; j++) {
                if (tiles[i][directions[j]].length > max) {
                    max = tiles[i][directions[j]].length;
                }
            }
        }
        return max;
    }

    return {
        collapse,
        test
    }
}